@dynamic
我们声明的属性, 在实现当中, 把它标识为dynamic,相当于说我们这些get,set方法,是在运行时添加, 而并不是在编译时给他声明好, 


- 动态运行时语言将函数决议推迟到运行时.(实际上就是在运行时, 为这个方法去添加具体的执行函数)
  - 当我们把一个属性,标识为dynamic的时候, 代表着不需要编译器编译时为我们生成这个属性的get,set方法, 的具体实现, 而是在运行时我们具体的调用了get方法或者set方法的时候再去添加的具体实现

- 编译时语言在编译期进行函数决议. (也就是说在编译期我就确定了一个方法名称所对应的函数执行体是哪一个, 在具体运行的过程当中了, 我们是没有办法去修改的.)



# [obj foo] 和 objc_msgSend()函数之间有什么关系.?

实际上在编译之后了, ` [obj foo]`就转换成了`objc_msgSend()`第一个参数是obj,第二参数是foo这个选择器, 就是编译之后前者转换成了后者. 


# runtime是如何通过selector找到对应的IMP地址的?

考察的点就是消息传递机制.
1.我们先查找当前实例所对应的类对象的缓存,看看是否有selector所对应的一个缓存的IMP实现,如果缓存命中了,我们就把命中的缓存返回给调用者,

2. 如果缓存没有命中,我们就根据当前类的方法列表查找selector对应的IMP实现. 当前类对象没有命中的话,再根据当前类superclass指针逐级查找父类的方法列表, 然后查找selector对应的IMP实现.


# 能否向`编译后`的类中添加实例变量?
关键词: `编译后`.

编译后的类不能,我们在编译之前,我们定义或者说创建的这个类,它已经完成了实例变量的布局, class_ro_t就是readonly, 就是编译后我们是没有办法进行修改的. 


#  能否向`动态添加`的类中添加实例变量?


我们在动态添加的这个类过程当中, 只有在调用它的注册类方法之前.  