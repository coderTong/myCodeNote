/*
.	匹配除换行符以外的任意字符
\w	匹配字母或数字或下划线或汉字
\s	匹配任意的空白符
\d	匹配数字
\b	匹配单词的开始或结束
^	匹配字符串的开始
$	匹配字符串的结束
*/


/*
*	重复零次或更多次
+	重复一次或更多次
?	重复零次或一次
{n}	重复n次
{n,}	重复n次或更多次
{n,m}	重复n到m次


*/



/*
 \W	匹配任意不是字母，数字，下划线，汉字的字符
 \S	匹配任意不是空白符的字符
 \D	匹配任意非数字的字符
 \B	匹配不是单词开头或结束的位置
 [^x]	匹配除了x以外的任意字符
 [^aeiou]	匹配除了aeiou这几个字母以外的任意字符
 */



/**
 分类	代码/语法	说明
 捕获	(exp)	匹配exp,并捕获文本到自动命名的组里
 (?<name>exp)	匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
 (?:exp)	匹配exp,不捕获匹配的文本，也不给此分组分配组号
 零宽断言	(?=exp)	匹配exp前面的位置
 (?<=exp)	匹配exp后面的位置
 (?!exp)	匹配后面跟的不是exp的位置
 (?<!exp)	匹配前面不是exp的位置
 注释	(?#comment)	这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读
 
 */


















@"^[0-9]+$"
　　它代表了字符串中只能包含>=1个0-9的数字，语法是不是有一些怪异？
　　下面我们先撇开iOS中的正则表达式的语法，用通俗的正则表达式语法来为介绍一下。（iOS语法与通俗的正则表达式语法相同，不同在于对转义字符的处理上(语言类的都相同)）
　　语法：
　　首先，特殊符号'^'和'$'。他们的作用是分别指出一个字符串的开始和结束。eg：
　　“^one”：表示所有以”one”开始的字符串（”one cat”，”one123″，·····）；
　　类似于:- (BOOL)hasPrefix:(NSString )aString;
　　“a dog$”：表示所以以”a dog”结尾的字符串（”it is a dog”，·····）；
　　类似于:- (BOOL)hasSuffix:(NSString )aString;
　　“^apple$”：表示开始和结尾都是”apple”的字符串，这个是唯一的~；
　　“banana”：表示任何包含”banana”的字符串。
　　类似于 iOS8的新方法- (BOOL)containsString:(NSString )aString,搜索子串用的。
　　‘'，'+'和'?'这三个符号，表示一个或N个字符重复出现的次数。它们分别表示“没有或更多”（[0,+∞]取整），“一次或更多”（[1,+∞]取整），“没有或一次”（[0,1]取整）。下面是几个例子：
　　“ab”：表示一个字符串有一个a后面跟着零个或若干个b（”a”, “ab”, “abbb”,……）；
　　“ab+”：表示一个字符串有一个a后面跟着至少一个b或者更多（ ”ab”, “abbb”,……）；
　　“ab?”：表示一个字符串有一个a后面跟着零个或者一个b（ ”a”, “ab”）；
　　“a?b+$”：表示在字符串的末尾有零个或一个a跟着一个或几个b（ ”b”, “ab”,”bb”,”abb”,……）。
　　可以用大括号括起来（{}），表示一个重复的具体范围。例如
　　“ab{4}”：表示一个字符串有一个a跟着4个b（”abbbb”）；
　　“ab{1,}”：表示一个字符串有一个a跟着至少1个b（”ab”,”abb”,”abbb”,……)；
　　“ab{3,4}”：表示一个字符串有一个a跟着3到4个b（”abbb”,”abbbb”)。
　　那么，“”可以用{0，}表示，“+”可以用{1，}表示，“?”可以用{0，1}表示
　　注意：可以没有下限，但是不能没有上限！例如“ab{,5}”是错误的写法
　　“ | ”表示“或”操作：
　　“a|b”：表示一个字符串里有”a”或者”b”；
　　“(a|bcd)ef”：表示”aef”或”bcdef”；
　　“(a|b)*c”：表示一串”a”"b”混合的字符串后面跟一个”c”；
　　方括号”[ ]“表示在括号内的众多字符中，选择1-N个括号内的符合语法的字符作为结果，例如
　　“[ab]“：表示一个字符串有一个”a”或”b”（相当于”a|b”）；
　　“[a-d]“：表示一个字符串包含小写的'a'到'd'中的一个（相当于”a|b|c|d”或者”[abcd]“）；
　　“^[a-zA-Z]“：表示一个以字母开头的字符串；
　　“[0-9]a”：表示a前有一位的数字；
　　“[a-zA-Z0-9]$”：表示一个字符串以一个字母或数字结束。
　　“.”匹配除“\r\n”之外的任何单个字符：
　　“a.[a-z]“：表示一个字符串有一个”a”后面跟着一个任意字符和一个小写字母；
　　“^.{5}$”：表示任意1个长度为5的字符串；
　　“\num” 其中num是一个正整数。表示”\num”之前的字符出现相同的个数，例如
　　“(.)\1″：表示两个连续的相同字符。
　　“10{1,2}” : 表示数字1后面跟着1或者2个0 (“10″,”100″)。
　　” 0{3,} ” 表示数字为至少3个连续的0 （“000”，“0000”，······）。
　　在方括号里用'^'表示不希望出现的字符，'^'应在方括号里的第一位。
　　“@[^a-zA-Z]4@”表示两个”@”中不应该出现字母）。
　　常用的还有：
　　“ \d ”匹配一个数字字符。等价于[0-9]。
　　“ \D”匹配一个非数字字符。等价于[^0-9]。
　　“ \w ”匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。
　　“ \W ”匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。
　　iOS中书写正则表达式，碰到转义字符，多加一个“\”,例如：
　　全数字字符：@”^\d+$”





















1.验证用户名和密码：”^[a-zA-Z]\w{5,15}$”
　　2.验证电话号码：（”^([\\d{3,4}-)\\d{7,8}$](file:///d%7B3,4%7D-)//d%7B7,8%7D$)”）
                                     　　eg：021-68686868  0511-6868686；
                                     　　3.验证手机号码：”^1[3|4|5|7|8][0-9]\\d{8}$”；
                                     　　4.验证身份证号（15位或18位数字）：”\\d{14}[[0-9],0-9xX]”；
                                     　　5.验证Email地址：(“^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\.\\w+([-.]\\w+)*$”)；
                                     　　6.只能输入由数字和26个英文字母组成的字符串：(“^[A-Za-z0-9]+$”) ;
                                     　　7.整数或者小数：^[0-9]+([.]{0,1}[0-9]+){0,1}$
                                     　　8.只能输入数字：”^[0-9]*$”。
                                     　　9.只能输入n位的数字：”^\\d{n}$”。
                                     　　10.只能输入至少n位的数字：”^\\d{n,}$”。
                                     　　11.只能输入m~n位的数字：”^\\d{m,n}$”。
                                     　　12.只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$”。
                                     　　13.只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。
                                     　　14.只能输入有1~3位小数的正实数：”^[0-9]+(\.[0-9]{1,3})?$”。
                                     　　15.只能输入非零的正整数：”^\+?[1-9][0-9]*$”。
                                     　　16.只能输入非零的负整数：”^\-[1-9][]0-9″*$。
                                     　　17.只能输入长度为3的字符：”^.{3}$”。
                                     　　18.只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。
                                     　　19.只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。
                                     　　20.只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。
                                     　　21.验证是否含有^%&',;=?$\”等字符：”[^%&',;=?$\x22]+”。
                                     　　22.只能输入汉字：”^[\u4e00-\u9fa5]{0,}$”。
                                     　　23.验证URL："http(s)?://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&=]*)?"。
                                     　　24.验证一年的12个月：”^(0?[1-9]|1[0-2])$”正确格式为：”01″～”09″和”10″～”12″。
                                     　　25.验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01″～”09″、”10″～”29″和“30”~“31”。
                                     　　26.获取日期正则表达式：[\\d{4](file:///d%7B4)}[年|\-|\.]\\d{\1-\12}[月|\-|\.]\\d{\1-\31}日?
                                                            　　评注：可用来匹配大多数年月日信息。
                                                            　　27.匹配双字节字符(包括汉字在内)：[^\x00-\xff]
                                                            　　评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
                                                            　　28.匹配空白行的正则表达式：\n\s*\r
                                                            　　评注：可以用来删除空白行
                                                            　　29.匹配HTML标记的正则表达式：<(\S*?)[^>]*>.*?</>|<.*? />
                                                            　　评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
                                                            　　30.匹配首尾空白字符的正则表达式：^\s*|\s*$
                                                            　　评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
                                                            　　31.匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*
                                                            　　评注：网上流传的版本功能很有限，上面这个基本可以满足需求
                                                            　　32.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
                                                            　　评注：表单验证时很实用
                                                            　　33.匹配腾讯QQ号：[1-9][0-9]\{4,\}
                                                            　　评注：腾讯QQ号从10 000 开始
                                                            　　34.匹配中国邮政编码：[1-9]\\d{5}(?!\d)
                                                            　　评注：中国邮政编码为6位数字
                                                            　　35.匹配ip地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。
































                                                            - (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
    {
        NSString *str = @"@jack12:【动物尖叫合辑】#肥猪流#猫头鹰这么尖叫[偷笑]、@船长: 老鼠这么尖叫、兔子这么尖叫[吃惊]、@花满楼: 莫名奇#小笼包#妙的笑到最后[好爱哦]！~ http://www.jianshu.com 电话: 17334332342";
        
        // 1.匹配@名字:
        // NSString *pattern = @"@.*?:";
        
        // 2.匹配URL
        // NSString *pattern = @"http(s)?://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&=]*)?";
        
        // 3.匹配话题 #....#
        // NSString *pattern = @"#.*?#";
        
        // 4.手机号码匹配
        NSString *pattern = @"1[3578]\\d{9}$";
        
        NSError *error = nil;
        /*
         typedef NS_OPTIONS(NSUInteger, NSRegularExpressionOptions) {
         NSRegularExpressionCaseInsensitive             = 1 << 0, //不区分字母大小写的模式
         NSRegularExpressionAllowCommentsAndWhitespace  = 1 << 1, //忽略掉正则表达式中的空格和#号之后的字符
         NSRegularExpressionIgnoreMetacharacters        = 1 << 2, //将正则表达式整体作为字符串处理
         NSRegularExpressionDotMatchesLineSeparators    = 1 << 3, //允许.匹配任何字符，包括换行符
         NSRegularExpressionAnchorsMatchLines           = 1 << 4, //允许^和$符号匹配行的开头和结尾
         NSRegularExpressionUseUnixLineSeparators       = 1 << 5, //设置\n为唯一的行分隔符，否则所有的都有效。
         NSRegularExpressionUseUnicodeWordBoundaries    = 1 << 6 //使用Unicode TR#29标准作为词的边界，否则所有传统正则表达式的词边界都有效
         };
         */
        NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:NSRegularExpressionCaseInsensitive error:&error];
        
        NSArray<NSTextCheckingResult *> *result = [regex matchesInString:str options:0 range:NSMakeRange(0, str.length)];
        if (result) {
            for (int i = 0; i<result.count; i++) {
                NSTextCheckingResult *res = result[i];
                NSLog(@"str == %@", [str substringWithRange:res.range]);
            }
        }else{
            NSLog(@"error == %@",error.description);
        }
    }
