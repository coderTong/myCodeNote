 # 内存管理方案
` 这里关于内存管理的讨论全部基于objc-runtime-680 `
# iOS操作系统是怎样对内存进行管理的?

针对不同场景会有不同的管理方案. 

## 场景:

- 1.TaggedPointer: 对于一些小对象,比如说NSNumber等, 对于这些小对象采用的就是TaggedPointer这种管理方案

- 2. NONPOINTER_ISA: 对于64架构下的应用程序采用的是`NONPOINTER_ISA`
  - 实际在64位架构下 ISA这个指针是占64个比特位的. 但是实际上有32位或者说40位就够用了.剩余的一些比特位是浪费的.苹果为了提搞内存的利用率, 在ISA当中剩余的这些比特位存储了关于内存管理方面数据内容. 所以这个叫做`非指针型的ISA `

- 3. 散列表: 复杂的数据结构,这里面包括了 `引用计数表` 和 ` 弱引用表`

 
# 非指针型的isa NONPOINTER_ISA 内存管理方案

在arm64架构下, isa指针一共有64个比特位, 我们来看看这64个比特位都存了那些内容

# 首先来看0~15位


![05-02-01](image/05-02-01.png)



- 第一位indexed
  - 图中第一位是一个叫indexed的标志位,  如果是0就表示这个isa指针是一个存的isa指针, 就是说这个isa指针就是当前对象的类对象的地址

  - 如果是1的话就表示这个isa指针存的内 容不仅仅是类对象的地址,  他里面还有一些关于内存管理方面的数据, 

- 第二位has_accoc(是否有关联对象)
 - 0就代表没有, 1就代表有

- 第三位has_cxx_dtor (这个函数或者这个变量标志表示的是当前对象是否有使用到c++相关的一些代码,或者c++语言方面的一些内容)
  - 在ARC当中, 实际上也可以通过这个标志位来表示有些对象是通过ARC来进行内存管理 的

- shiftcls剩下的13位就是当前对象的类对象的指针地址


![05-02-02](image/05-02-02.png)

# 16~31位也是当前对象的类对象的指针地址



# 32~47

![05-02-02](image/05-02-04.png)
### 32~35位也是当前对象的类对象的指针地址
### 36~41 magic不做深入探讨

### 42: weakly_referenced:弱引用, 标识了这个对象是否有相应的一个弱引用指针

### 43deallocating: 标识当前对象是否正在进行dealloc操作, 

### 44has_sidetable_rc:  指当前这个isa指针当中, 如果所存储的引用计数达到了上线的话, 那么需要外挂一个`sidetable`, 这样一个数据结构, 去存储相关的引用计数内容,就是后面要说的散列表.

### 45~47extra_rc: 额外的引用计数, 当我们引用计数在一个很小的值得范围之内呢,就会存到isa指针当中, 而不是有一个单独的引用计数表去存.


![05-02-02](image/05-02-05.png)
# 48~63 也都是extra_rc 




![05-02-06](image/05-02-06.png)

# 散列表方式

散列表方式在源码中是通过, `SideTables()`结构实现的. 


在SideTables()下面, 挂了很多`sideTable`这么样一个数据结构.这些数据结构在不同的架构上面是不同个数的. 在非嵌入式系统当中,`sideTable` 这种表一共有64个. 要说明一下的是`SideTables()`这个表示哈希表,  我们可以通过一个对象指针来具体找到他对应的引用计数表或者说弱引用表. 在哪一张`sideTable`当中. 


![05-02-06](image/05-02-07.png)
### sideTable结构


# 问: 为什么不是一个SideTable?
为什么不是一个SideTable, 而是多个SideTable组成一个SideTables()这样一个数据结构了?

说: 假如只有一张SideTable,  相当于我们在内存当中,分配的所有对象的引用计数或者是弱引用存储, 放到一张大表当中, 这个时候如果说我们要操作某一个对象的引用计数值,进行修改, 进行加一或者减一的操作的话, 由于所有的这个对象可能是在不同的线程中分配创建的,  包括调用他们的release, retain等, 这个时候需要对表进行加锁处理保证数据的访问安全, 这样就存在效率问题,成千上万个对象操作一张表就会有效率问题.


![05-02-08](image/05-02-08.png)


# 解决一张表效率问题: 分离锁

![05-02-09](image/05-02-09.png)


# 如何实现快速分流了?



我们通过一个对象的指针,如何快速的定位它属于那张`SideTable`, 


![05-02-10](image/05-02-10.png)



通过hash查找是为了提高查找效率...



# 数据结构


- Spinlock_t (自旋锁)

1.Spinlock_t是 `忙等`, 如果当前锁已经被其他线程占用, 当前锁就会一直去探测
2.适用于轻量访问


- RefcountMap (引用计数表)

引用计数表是通过什么实现的呢, 答它是通过哈希表来实现的.

为什么是哈希表实现的呢? 答: 查找效率高, 插入和获取是通过同一个算法得到的,避免了for循环遍历...



![05-02-11](image/05-02-11.png)



size_t 就是对应的一个引用计数值,
weakly_referenced(对象是否有弱引): 0表示没有, 1表示有



- weak_table_t (弱引用表)

![05-02-13](image/05-02-13.png)


![05-02-12](image/05-02-12.png)






# MRC 和 ARC



## MRC

![05-02-12](image/05-02-14.png)


## ARC 自动引用计数

ARC是LLVM(编译器)和Runtime协作的结果
ARC中禁止手动调用`retain`/`release`/`retainCount`/`dealloc`
ARC 中新增`weak`, `strong`属性关键字



## ARC 和MRC 有什么区别了?

MRC是手动管理内存, ARC是编译器和runtime协作管理内存.





# 引用计数管理

实现原理分析

- alloc 实现

经过一系列调用, 最终调用了c函数calloc.
此时并没有设置引用计数为1,  获取得到retainCount值为1的原因是?



- retain


![05-02-15](image/05-02-15.png)
两次哈希查找,得到一个值然后对其进行加一操作



- release


![05-02-16](image/05-02-16.png)


- retainCount

![05-02-16](image/05-02-17.png)

- dealloc 实现

不是非指针型的isa指针, 没有弱引用, 没有关联对象, 没有c++相关内没有涉及ARC, 没有采用sidetable 存储引用计数, 就可以直接调用c函数free直接释放,  否则就调用object_dispose()



![05-02-19](image/05-02-19.png)



![05-02-20](image/05-02-20.png)



objc_destructInstance() 实现


![05-02-21](image/05-02-21.png)


clearDeallocating() 实现


![05-02-22](image/05-02-22.png)

